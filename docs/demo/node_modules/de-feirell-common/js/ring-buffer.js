/**
 * The `RingBuffer` class is a limited queue which is implemented as a RingBuffer.
 * 
 * @class
 * @param {number} length how much space this RingBuffer should provide
 */
function RingBuffer(length) {
    length = parseInt(length);

    if (!isFinite(length) || length < 0)
        throw 'The length has to be at least one'

    let pointer = 0;

    Object.defineProperties(this, {
        /**
         * The capacity of this RingBuffer.
         * @constant
         * @member {number} RingBuffer#length 
         */
        length: {
            value: length
        },
        /**
         * The buffer of this RingBuffer, you should not directly access this buffer.
         * @constant
         * @member {any[]} RingBuffer#buffer 
         */
        buffer: {
            value: new Array(length)
        },
        /**
         * The current pointer in this RingBuffer. If you set the pointer this value gets normalized! 
         * @member {number} RingBuffer#pointer
         */
        pointer: {
            set: function (v) {
                length = parseInt(length);

                if (!isFinite(length))
                    throw 'the pointer has to be a finite integer'

                let p = (this.length + (v % this.length)) % this.length;
                if (p !== NaN)
                    pointer = p;
            },
            get: function () {
                return pointer
            }
        }
    })
}

/**
 * Resets this buffer, empties the buffer and resets the pointer.
 */
RingBuffer.prototype.reset = function reset() {
    for (let i = 0; i < this.length; i++)
        this.buffer[i] = undefined;

    this.pointer = 0;
}

/**
 * Adds a value at the start of the buffer.
 * @param {any} value the value to be added
 */
RingBuffer.prototype.add = function add(v) {
    this.buffer[this.pointer++] = v;
}

/**
 * @callback RingBuffer~forEachCb
 * @param {any} value the current value
 * @param {number} index the index of the current value
 */

/**
 * Iterates over the buffer
 * @param {RingBuffer~forEachCb} callback 
 */
RingBuffer.prototype.forEach = function forEach(callback) {
    for (let i = 1; i <= this.length; i++) {
        let p = this.pointer - i;
        if (p < 0) p = this.length + p;

        callback(this.buffer[p], i)
    }
}
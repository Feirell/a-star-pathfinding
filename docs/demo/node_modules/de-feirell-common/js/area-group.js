/**
 * AreaGroup groups areas together so they can be used with some collection sense, but because the collection consist of Areas you can aplly about the same methods, for example can you iterate over the areas and their cells.
 * @class
 * @param {Area[]} areas
 */
function AreaGroup(areas) {
    if (areas.length == 0)
        throw 'at least one Area has to be added';

    let usableAreas = [];

    for (var i = 0; i < areas.length; i++) {
        let inst = areas[i];

        if (!(inst instanceof Area))
            throw inst + ' is not an instance of Area';

        usableAreas[usableAreas.length] = inst;
    }

    /**
     * The areas this Group constist of, because {@link Area} is inmuteable and this are array is frozen, AreaGroup is inmuteable.
     * @member {Area[]} AreaGroup#areas
     */
    Object.defineProperty(this, 'areas', {
        value: Object.freeze(usableAreas)
    })
}

/**
 * Checks wether the defined x,y coordinates are in this AreaGroup
 * 
 * @param {number} x 
 * @param {number} y 
 * @returns {boolean} returns wether or not the defined coordinate is in this AreaGroup
 */
AreaGroup.prototype.contains = function contains(x, y) {
    for (let i = 0; i < this.areas.length; i++)
        if (this.areas[i].contains(x, y))
            return true;

    return false;
}

/**
 * Returns a string representation of this area as 'Area{areas: [Area{...}, ...]}'
 * 
 * @returns {string}
 */
AreaGroup.prototype.toString = function toString() {
    let areaString = '';

    for (let i = 0; i < this.areas.length; i++)
        areaString += this.areas[i].toString() + (i != this.areas.length - 1 ? ', ' : '');

    return 'AreaGroup{areas: [' + areaString + ']}';
}

/**
 * Creates a iterator over every Area of this group and their cells.
 * 
 * @returns {Area~AreaIterator} iterator 
 */
AreaGroup.prototype.iterator = function iterator() {
    let areas = this.areas;

    if (areas.length == 0)
        return undefined;

    let cA = 0,
        currentIterator = areas[0].iterator();

    return {
        hasNext: function hasNext() {
            while (true) {
                if (currentIterator.hasNext())
                    return true;

                if (++cA >= areas.length)
                    return false;

                currentIterator = areas[cA].iterator();
            }
        },
        next: function next() {
            if (!this.hasNext())
                return undefined;

            return currentIterator.next();
        },
        forEach: function forEach(func) {
            while (this.hasNext())
                func(this.next());
        }
    }
}
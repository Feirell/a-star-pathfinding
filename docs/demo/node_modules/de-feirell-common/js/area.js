/**
 * The Area is a class which contains four members which are sorted and checked for validity on construction.
 * Each of the members is exposed as a read only number.
 * 
 * 
 * @class
 * @param {number} startX 
 * @param {number} endX 
 * @param {number} startY 
 * @param {number} endY 
 */
function Area(startX, endX, startY, endY) {
    startX = parseInt(startX);
    endX = parseInt(endX);

    startY = parseInt(startY);
    endY = parseInt(endY);

    if (startX === NaN)
        throw 'startX has to be a number';

    if (endX === NaN)
        throw 'endX has to be a number';

    if (startY === NaN)
        throw 'startY has to be a number';

    if (endY === NaN)
        throw 'endY has to be a number';


    Object.defineProperties(this, {
        /**
         * Start x
         * @constant
         * @member {number} Area#sX
         */
        sX: {
            value: startX < endX ? startX : endX
        },
        /**
         * End x
         * @constant
         * @member {number} Area#eX
         */
        eX: {
            value: endX > startX ? endX : startX
        },

        /**
         * Start y
         * @constant
         * @member {number} Area#sY
         */
        sY: {
            value: startY < endY ? startY : endY
        },
        /**
         * End y
         * @constant
         * @member {number} Area#eX
         */
        eY: {
            value: endY > startY ? endY : startY
        }
    })
}

/**
 * Tries to assume the area from an two dimensional array.
 * calls internaly `new Area(0, array.length, 0, array[0].length)`
 * @param {any[][]} array 
 */
Area.assumFromTwoDArray = function (array) {
    return new Area(0, array.length, 0, array[0].length);
}

/**
 * Checks wether the defined x,y coordinates are in this Area
 * 
 * @param {number} x 
 * @param {number} y 
 * @returns {boolean} returns wether or not the defined coordinate is in this Area
 */
Area.prototype.contains = function contains(x, y) {
    return x >= this.sX && x <= this.eX && y >= this.sY && y <= this.sY;
}

/**
 * Returns a string representation of this area as 'Area{x: [sX,eX],y: [sY,eY]}'
 * 
 * @returns {string}
 */
Area.prototype.toString = function toString() {
    return 'Area{x: [' + this.sX + ',' + this.eX + '],y: [' + this.sY + ',' + this.eY + ']}';
}

/**
 * @typedef {Object} Area~AreaIterator~Point
 * @property {number} x The X Coordinate
 * @property {number} y The Y Coordinate
 */

/**
 * Creates a iterator over every cell of this area.
 * 
 * @returns {Area~AreaIterator} iterator 
 */
Area.prototype.iterator = function iterator() {
    const area = this;

    let cX = area.sX,
        cY = area.sY;

    /**
     * @class Area~AreaIterator
     */
    return {
        /**
         * Yields wether or not the next call of next() will return a value
         * @method Area~AreaIterator#hasNext
         * @returns {boolean} wether or not there is a next value
         */
        hasNext: function hasNext() {
            return cX <= area.eX && cY <= area.eY;
        },
        /**
         * Return the next Point
         * @method Area~AreaIterator#next
         * @returns {Area~AreaIterator~Point?} the next Point
         */
        next: function next() {
            if (!this.hasNext())
                return undefined;

            const ret = {
                x: cX,
                y: cY
            };

            if (++cX > area.eX) {
                cX = area.sX;
                cY++;
            }

            return ret;
        },
        /**
         * Callback for [AreaIterator.forEach()]{@link Area~AreaIterator#forEach}
         * @callback Area~AreaIterator~forEachCb
         * @param {Area~AreaIterator~Point} point
         */


        /**
         * Shorthand function which calls the callback for each item this iterator returns
         * @param {Area~AreaIterator~forEachCb} callback Callbackfunction
         * @method Area~AreaIterator#forEach
         */
        forEach: function forEach(callback) {
            while (this.hasNext())
                callback(this.next());
        }
    }
}